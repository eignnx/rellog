[sig [Prefix][Suffix][Compound]][doc
    """
    Relates a list `Compound` to some partitioning of itself into a `Prefix` 
    and a `Suffix`. Also works for text strings.
    """
]
[prefix {}][Suffix][compound Suffix]
[prefix {A ..As}][Suffix][compound {A ..Compound}]
    - [prefix As][suffix Suffix][Compound]

[[comment
    """
    [Prefix][Suffix][Compound]
        - [txt_prefix Prefix][txt_suffix Suffix][txt_compound Compound]
    """
]]

[sig [Forward][Backward]][doc "Relates a list to its reversal."]
[forward {}][backward {}]
[forward {A ..As}][Backward]
    - [forward As][backward AsBackward]
    - [prefix AsBackward][suffix {A}][compound Backward]

[[todo
    """
    `[[mode [forward out][backward in]]]` loops forever.
    Does it need to be an intrinsic?
    """
]]

[list {Member ..Rest}][Member]
[list {Other ..Rest}][Member]
    - [list Rest][Member]

[sig [List][Members]][doc "Relates a list to a (sub?)list of its members."]
[List][members {}]
[List][members {Member ..Rest}]
    - [List][members Rest]
    - [List][Member]

[must_be [list {}]]
[must_be [list {X ..Xs}]]
    - [must_be [list Xs]]

[can_be [list {}]]
[can_be [list {X ..Xs}]]
[can_be [list L]]
    - [must_be_var L]

[can_be [int N]]
    | [must_be_num N]
    | [must_be_var N]

[must_be [num N]]
    - [must_be_num N]

[sig [List][Last]][doc "Relates a list to its last element."]
[list {Last}][Last]
[list {X ..Xs}][Last]
    - [list Xs][Last]

[[todo "mode [list out][len in] is broken"]]
[sig [List][Len]][doc "Relates a list to it's length."]
[list {}][len 0]
[list {X ..Xs}][Len]
    - [list Xs][len XsLen]
    - [pred XsLen][succ Len]


[sig [io {println}]][doc "Prints a newline character to stdout."]
[io {println}]
    - [io_writeln ""][stream stdout]

[sig [io {println Text}]][doc "Prints `Text` to stdout, followed by a newline character."]
[io {println Text}]
    - [io_writeln Text][stream stdout]

[sig [io {print Text}]][doc "Prints `Text` to stdout."]
[io {print Text}]
    - [io_write Text][stream stdout]


[help Signature]
    - [sig Signature][doc DocTxt]
    - [term Signature][text SigTxt]
    - [io {println}]
    - [io {print "Relation: "}]
    - [io {println SigTxt}]
    - [io {println "--------------"}]
    - [io {println DocTxt}]
    - [io {println}]

[fn {factorial 0}][ret 1]
[fn {factorial 1}][ret 1]
[fn {factorial N}][Ret]
    - [gt N][lt 1]
    - [succ N][pred PredN]
    - [fn {factorial PredN}][ret Fact]
    - [product Ret][x N][y Fact]

[sig [Formula][Result]][doc
    """
    Computes an arithmetic expression given by `Formula` and stores the result 
    in `Result`.


    Available operations are:

        - `{X add Y}` for addition

        - `{X sub Y}` for subtraction

        - `{X mul Y}` for multiplication

        - `{X div Y}` for integer division

        - `{X mod Y}` for euclidean modulus

        - `{neg X}` for negation
    """
]
[formula N][result N]
    - [must_be_num N]
[formula {A0 mul B0}][result C]
    - [formula A0][result A]
    - [formula B0][result B]
    - [den A][quo B][rem 0][num C]
[formula {A0 div B0}][result C]
    - [formula A0][result A]
    - [formula B0][result B]
    - [num A][den B][quo C][rem Ignore]
[formula {A0 mod B0}][result C]
    - [formula A0][result A]
    - [formula B0][result B]
    - [num A][den B][quo Ignore][rem C]
[formula {A0 add B0}][result C]
    - [formula A0][result A]
    - [formula B0][result B]
    - [subtrahend A][difference B][minuend C]
[formula {A0 sub B0}][result C]
    - [formula A0][result A]
    - [formula B0][result B]
    - [minuend A][subtrahend A][difference C]
[formula {neg A0}][result B]
    - [formula A0][result A]
    - [minuend 0][subtrahend A][difference B]


[[comment "Documentation for builtins"]]

[sig [Rel][Attrs]][doc
    """
    Relates a relation to a list of its attributes. An attribute is a 
    `[key Value]` pair.
    """
]

[sig [Attr][Key][Value]][doc
    "Relates an attribute (a `[key Value]` pair) to its key and value."
]

[sig [Rel][Key][Value]][doc
    """
    Extracts a value from a relation given the key name. Faster than searching 
    through a list of the relation's attributes.
    """
]

[sig [Eq]][doc
    """
    Unifies together the elements of the provided list.
    
    Syntax sugar allows these to be equivalent expressions:

    -- A = B = C

    -- [eq {A B C}]
    """
]

[sig [Term][Variables]][doc
    "Relates a term to the list of variables contained in that term."
]

[sig [Original][Duplicate]][doc
    """
    Creates a duplicate of `Original` and unifies it with `Duplicate`.
    """
]

[sig [Original][Duplicate][Renaming][Renamed]][doc
    """
    Creates a duplicate of `Original` and unifies it with `Duplicate`.

    The variables in the list `Renaming` that appear in `Original` will be
    renamed and their new names will be put in the list `Renamed`.

    # Example

    ```
    -- [original [a A][b B][ab {A B}]][Duplicate][renaming {A Z}][Renamed]
        - Duplicate = [a A_1][B][ab {A_1 B}]
        - Renamed = {A_1 Z}
    ```
    """
]

[sig [SnakeCase][PascalCase]][doc
    "Convert symbols between snake_case and PascalCase."
]

[sig [Gt][Lt]][doc
    "True if the number `Gt` is greater than the number `Lt`."
]

[sig [Gte][Lte]][doc
    "True if the number `Gte` is greater than or equal to the number `Lte`."
]

[sig [MustBeVar]][doc
    "Succeeds if its argument is an unbound variable."
]

[sig [MustBeNum]][doc
    "Succeeds if its argument is an instantiated number."
]

[sig [MustBeSym]][doc
    "Succeeds if its argument is an instantiated symbol."
]

[sig [MustBeTxt]][doc
    "Succeeds if its argument is an instantiated text string."
]

[sig [MustBeRel]][doc
    "Succeeds if its argument is an instantiated relation structure."
]

[sig [TxtPrefix][TxtSuffix][TxtCompound]][doc
    "Pushes a suffix onto a text string."
]

[sig [Pred][Succ]][doc
    "Relates two adjacent integers: a predecessor and a successor."
]

[sig [True]][doc "Always succeeds."]
[sig [False]][doc "Always fails."]
[sig [Not]][doc
    """
    Succeeds if the goal passed to it fails, fails if the goal succeeds at least 
    once. Note: This is safe because the knowledgebase is immutable.
    """
]

[sig [IoWriteln][Stream]][doc
    "Writes a text string to `Stream`, and then writes a newline character."
]

[sig [IoWrite][Stream]][doc
    "Writes a text string to `Stream`."
]

[sig [Term][Text]][doc
    "Relates a term to its text string representation."
]

[sig [Builtins]][doc "Lists all builtin relations."]

[sig [Cwd]][doc "Gives the current working directory."]

[sig [Cd]][doc
    """
    Changes the current working directory to the path provided as an argument.
    """
]

[sig [Ls]][doc
    """
    Unifies its argument with a list of file/directory names from the current 
    working directory.
    """
]

[Min][Sub][Dif]
    - [minuend Min][subtrahend Sub][difference Dif]

[sig [Minuend][Subtrahend][Difference]][doc
    """
    Expresses the relationship: `Minuend - Subtrahend = Difference`.
    
    To perform addition, use mode `[subtrahend][difference][Minuend]`.

    Alias: [Min][Sub][Dif]
    """
]

[Num][Den][Quo][Rem]
    - [numerator Num][denominator Den][quotient Quo][remainder Rem]

[sig [Numerator][Denominator][Quotient][Remainder]][doc
    """
    Expresses the relationship: `Numerator/Denominator = Quotient (with a 
    remainder of Remainder)`. More precisely, the relationship is `Numerator = 
    Quotient * Denominator + Remainder`.
    
    Can be used to express divisibility (when Remainder is set to 0), as well as
    multiplication (when Remainder is 0).

    Alias: [Num][Den][Quo][Rem]


    Common Modes:

    [num][den][Quo][Rem]   <=> quo = num / den, rem = num % den

    [Num][den][quo][rem]   <=> num = den * quo + rem

    [Num][den 1][quo][rem] <=> num = quo + rem

    [Num][den][quo 1][rem] <=> num = den + rem

    [Num][den][quo][rem 0] <=> num = den * quo

    [num][Den][quo][rem]   <=> den = (num - rem) / quo

    [num][den][Quo][rem]   <=> quo = (num - rem) / den

    [num][Den][quo 1][rem] <=> den = num - rem

    [num][den 1][Quo][rem] <=> quo = num - rem
    """
]

[Nat][Base][Digits]
    - [Nat][Base][RevDigits]
    - [forwards RevDigits][backwards Digits]

[nat 0][Base][revdigits {}]
[Nat][Base][revdigits {Rem ..Ds}]
    - [num Nat][den Base][Quo][Rem]
    - [nat Quo][Base][revdigits Ds]

[[todo
    "[[mode [num out][den in][quo out][rem in]]] not supported."
]]

[sig [FilePath][Clauses][Directives]][doc
    """
    Relates a rellog source file given by `FilePath` to that files contained 
    `Clauses` and `Directives`.
    """
]

[undocumented_sig S]
    - [clause_head S][clause_body B]
    - [not [Sig][Doc] ~ S]
    - [not [Sig][Doc]; (Sig ~ S)]
